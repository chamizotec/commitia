#!/usr/bin/env bash
#
# CommitIA - Gerador de commits inteligentes com IA
# https://github.com/chamizotec/commitia
#
# Gera mensagens de commit seguindo o padrão Conventional Commits
# usando inteligência artificial para analisar suas alterações.
#

set -e

VERSION="1.0.1"
SCRIPT_NAME="commitia"
REPO_URL="https://github.com/chamizotec/commitia"
REPO_RAW_URL="https://raw.githubusercontent.com/chamizotec/commitia/main"

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Configurações padrão (serão aplicadas após carregar o config)
CONFIG_FILE="${HOME}/.commitiarc"
DRY_RUN=false
INTERACTIVE=false
AMEND=false

# ============================================================================
# Funções de utilidade
# ============================================================================

print_banner() {
  echo -e "${PURPLE}"
  echo '   ____                          _ _   ___    _    '
  echo '  / ___|___  _ __ ___  _ __ ___ (_) |_|_ _|  / \   '
  echo ' | |   / _ \| '\''_ ` _ \| '\''_ ` _ \| | __|| |  / _ \  '
  echo ' | |__| (_) | | | | | | | | | | | | |_ | | / ___ \ '
  echo '  \____\___/|_| |_| |_|_| |_| |_|_|\__|___/_/   \_\'
  echo -e "${NC}"
  echo -e "${CYAN}  Commits inteligentes com IA - v${VERSION}${NC}"
  echo ""
}

print_help() {
  print_banner
  echo -e "${BOLD}USO:${NC}"
  echo "  $SCRIPT_NAME [opções] [arquivos...]"
  echo ""
  echo -e "${BOLD}OPÇÕES:${NC}"
  echo "  -m, --message <texto>    Contexto adicional para a mensagem de commit"
  echo "  -t, --type <tipo>        Força um tipo específico de commit"
  echo "  -s, --scope <escopo>     Define o escopo manualmente"
  echo "  -i, --interactive        Modo interativo (confirma antes de commitar)"
  echo "  -d, --dry-run            Apenas mostra a mensagem sem fazer commit"
  echo "  -a, --amend              Altera o último commit"
  echo "  --no-stage               Não adiciona arquivos ao stage automaticamente"
  echo "  --provider <provider>    Define o provedor de IA (amp, openai, ollama)"
  echo "  --lang <idioma>          Idioma da mensagem (pt, en, es)"
  echo "  --update                 Atualiza para a versão mais recente"
  echo "  -v, --version            Mostra a versão"
  echo "  -h, --help               Mostra esta ajuda"
  echo ""
  echo -e "${BOLD}EXEMPLOS:${NC}"
  echo "  $SCRIPT_NAME                        # Commit de todas as alterações"
  echo "  $SCRIPT_NAME src/                   # Commit apenas da pasta src/"
  echo "  $SCRIPT_NAME -m \"corrige bug X\"     # Com contexto adicional"
  echo "  $SCRIPT_NAME -t fix -s auth         # Força tipo 'fix' com escopo 'auth'"
  echo "  $SCRIPT_NAME -i                     # Modo interativo"
  echo "  $SCRIPT_NAME -d                     # Dry-run (apenas mostra a mensagem)"
  echo ""
  echo -e "${BOLD}TIPOS DE COMMIT:${NC}"
  echo "  feat      Nova funcionalidade"
  echo "  fix       Correção de bug"
  echo "  docs      Documentação"
  echo "  style     Formatação, ponto-e-vírgula, etc."
  echo "  refactor  Refatoração de código"
  echo "  test      Adição ou correção de testes"
  echo "  chore     Tarefas de manutenção"
  echo "  perf      Melhorias de performance"
  echo "  ci        Alterações de CI/CD"
  echo "  build     Sistema de build ou dependências"
  echo "  revert    Reversão de commit anterior"
  echo ""
  echo -e "${BOLD}CONFIGURAÇÃO:${NC}"
  echo "  Crie ~/.commitiarc ou defina variáveis de ambiente:"
  echo "  - COMMITIA_PROVIDER: amp, openai, ollama (padrão: amp)"
  echo "  - COMMITIA_LANGUAGE: pt, en, es (padrão: pt)"
  echo "  - COMMITIA_AUTO_STAGE: true, false (padrão: true)"
  echo ""
}

print_version() {
  echo "CommitIA v${VERSION}"
}

error() {
  echo -e "${RED}✗ Erro: $1${NC}" >&2
  exit 1
}

warn() {
  echo -e "${YELLOW}⚠ Aviso: $1${NC}" >&2
}

success() {
  echo -e "${GREEN}✓ $1${NC}"
}

info() {
  echo -e "${BLUE}ℹ $1${NC}"
}

# ============================================================================
# Validações
# ============================================================================

check_dependencies() {
  # Verifica se está em um repositório git
  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    error "Não está em um repositório Git"
  fi

  # Verifica o provedor de IA
  case "$AI_PROVIDER" in
    amp)
      if ! command -v amp &>/dev/null; then
        error "amp CLI não encontrado. Instale em: https://ampcode.com"
      fi
      ;;
    openai)
      if [ -z "$OPENAI_API_KEY" ]; then
        error "OPENAI_API_KEY não definida"
      fi
      if ! command -v curl &>/dev/null; then
        error "curl não encontrado"
      fi
      ;;
    ollama)
      if ! command -v ollama &>/dev/null; then
        error "Ollama não encontrado. Instale em: https://ollama.ai"
      fi
      ;;
    *)
      error "Provedor de IA desconhecido: $AI_PROVIDER"
      ;;
  esac
}

check_staged_changes() {
  if [ -z "$(git diff --staged --name-only)" ]; then
    return 1
  fi
  return 0
}

check_unstaged_changes() {
  if [ -z "$(git diff --name-only)" ] && [ -z "$(git ls-files --others --exclude-standard)" ]; then
    return 1
  fi
  return 0
}

# ============================================================================
# Atualização
# ============================================================================

do_update() {
  print_banner
  info "Verificando atualizações..."
  
  # Verifica se curl está disponível
  if ! command -v curl &>/dev/null; then
    error "curl é necessário para atualização. Instale o curl primeiro."
  fi
  
  # Cria diretório temporário
  local temp_dir
  temp_dir=$(mktemp -d)
  trap "rm -rf $temp_dir" EXIT
  
  # Baixa a versão remota para verificar
  info "Baixando informações da versão mais recente..."
  local remote_script="$temp_dir/commitia"
  
  if ! curl -fsSL "$REPO_RAW_URL/bin/commitia" -o "$remote_script" 2>/dev/null; then
    error "Não foi possível conectar ao repositório. Verifique sua conexão."
  fi
  
  # Extrai versão remota
  local remote_version
  remote_version=$(grep -m1 '^VERSION=' "$remote_script" | cut -d'"' -f2)
  
  if [ -z "$remote_version" ]; then
    error "Não foi possível determinar a versão remota"
  fi
  
  echo ""
  echo -e "  Versão atual:  ${YELLOW}$VERSION${NC}"
  echo -e "  Versão remota: ${GREEN}$remote_version${NC}"
  echo ""
  
  # Compara versões
  if [ "$VERSION" = "$remote_version" ]; then
    success "Você já está na versão mais recente!"
    exit 0
  fi
  
  # Pergunta se quer atualizar
  echo -e "${YELLOW}Deseja atualizar para a versão $remote_version? [S/n]${NC}"
  read -r -n 1 response
  echo ""
  
  if [[ $response =~ ^[Nn]$ ]]; then
    info "Atualização cancelada"
    exit 0
  fi
  
  # Determina o diretório de instalação
  local install_dir
  local current_script
  current_script=$(command -v commitia 2>/dev/null || echo "$HOME/.local/bin/commitia")
  install_dir=$(dirname "$current_script")
  
  # Faz backup do script atual
  info "Criando backup..."
  cp "$current_script" "$temp_dir/commitia.backup" 2>/dev/null || true
  
  # Instala a nova versão
  info "Instalando versão $remote_version..."
  
  if cp "$remote_script" "$current_script" && chmod +x "$current_script"; then
    success "Atualizado com sucesso para a versão $remote_version!"
    echo ""
    echo -e "${CYAN}Novidades: ${REPO_URL}/releases${NC}"
  else
    # Tenta restaurar backup
    warn "Falha na atualização. Restaurando versão anterior..."
    cp "$temp_dir/commitia.backup" "$current_script" 2>/dev/null || true
    error "Não foi possível atualizar. Verifique as permissões."
  fi
}

# ============================================================================
# Carrega configuração
# ============================================================================

load_config() {
  # Carrega o arquivo de configuração se existir
  if [ -f "$CONFIG_FILE" ]; then
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
  fi
  
  # Aplica valores padrão APÓS carregar o config
  # Prioridade: default < config < linha de comando
  # Se não foi definido via linha de comando, usa config ou default
  AI_PROVIDER="${CLI_PROVIDER:-${COMMITIA_PROVIDER:-amp}}"
  LANGUAGE="${CLI_LANGUAGE:-${COMMITIA_LANGUAGE:-pt}}"
  AUTO_STAGE="${CLI_AUTO_STAGE:-${COMMITIA_AUTO_STAGE:-true}}"
}

# ============================================================================
# Extração de informações
# ============================================================================

get_task_id_from_branch() {
  local branch
  branch=$(git branch --show-current 2>/dev/null || echo "")
  
  if [ -n "$branch" ]; then
    # Padrões comuns: ENP-1234, JIRA-123, feature/ABC-999, etc.
    echo "$branch" | grep -oE '[A-Z]+-?[0-9]+' | head -1
  fi
}

get_staged_diff() {
  git diff --staged
}

get_staged_files() {
  git diff --staged --name-only
}

# ============================================================================
# Geração de mensagem com IA
# ============================================================================

build_prompt() {
  local task_id="$1"
  local context="$2"
  local forced_type="$3"
  local forced_scope="$4"
  local lang="$5"
  
  local lang_text
  case "$lang" in
    pt) lang_text="em português" ;;
    en) lang_text="in English" ;;
    es) lang_text="en español" ;;
    *) lang_text="em português" ;;
  esac
  
  local scope_text
  if [ -n "$forced_scope" ]; then
    scope_text="Use '$forced_scope' como escopo."
  elif [ -n "$task_id" ]; then
    scope_text="Use '$task_id' como escopo."
  else
    scope_text="Determine o escopo baseado nos arquivos alterados."
  fi
  
  local type_text
  if [ -n "$forced_type" ]; then
    type_text="Use o tipo '$forced_type'."
  else
    type_text="Tipos permitidos: feat, fix, docs, style, refactor, test, chore, perf, ci, build, revert."
  fi
  
  local prompt="Analise 'git diff --staged' e gere uma mensagem de commit $lang_text no formato 'tipo(escopo): descrição'. $type_text $scope_text A descrição deve ser curta, começar com minúscula e não terminar com ponto."
  
  if [ -n "$context" ]; then
    prompt="$prompt Contexto adicional: \"$context\"."
  fi
  
  prompt="$prompt Retorne APENAS a mensagem no formato correto, sem explicações ou texto adicional."
  
  echo "$prompt"
}

generate_with_amp() {
  local prompt="$1"
  echo "$prompt" | amp -x --dangerously-allow-all 2>&1
}

generate_with_openai() {
  local prompt="$1"
  local diff
  diff=$(get_staged_diff)
  
  local response
  response=$(curl -s https://api.openai.com/v1/chat/completions \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $OPENAI_API_KEY" \
    -d "{
      \"model\": \"gpt-4o-mini\",
      \"messages\": [
        {\"role\": \"system\", \"content\": \"Você é um assistente especializado em gerar mensagens de commit seguindo Conventional Commits.\"},
        {\"role\": \"user\", \"content\": \"$prompt\n\nDiff:\n$diff\"}
      ],
      \"temperature\": 0.3
    }")
  
  echo "$response" | grep -o '"content":"[^"]*"' | sed 's/"content":"//;s/"$//' | head -1
}

generate_with_ollama() {
  local prompt="$1"
  local diff
  diff=$(get_staged_diff)
  
  local full_prompt="$prompt

Diff:
$diff"
  
  ollama run codellama "$full_prompt" 2>/dev/null
}

generate_commit_message() {
  local prompt="$1"
  local output
  
  case "$AI_PROVIDER" in
    amp)
      output=$(generate_with_amp "$prompt")
      ;;
    openai)
      output=$(generate_with_openai "$prompt")
      ;;
    ollama)
      output=$(generate_with_ollama "$prompt")
      ;;
  esac
  
  # Extrai a mensagem no formato correto
  echo "$output" | grep -oE '(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)\([^)]*\):.*' | head -1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# ============================================================================
# Execução do commit
# ============================================================================

do_commit() {
  local message="$1"
  local amend_flag=""
  
  if [ "$AMEND" = true ]; then
    amend_flag="--amend"
  fi
  
  # shellcheck disable=SC2086
  git commit $amend_flag -m "$message"
}

# ============================================================================
# Main
# ============================================================================

main() {
  # Parse de argumentos
  FILES=()
  CONTEXT_MSG=""
  FORCED_TYPE=""
  FORCED_SCOPE=""
  
  # Variáveis CLI (prioridade sobre config)
  CLI_PROVIDER=""
  CLI_LANGUAGE=""
  CLI_AUTO_STAGE=""
  
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h|--help)
        print_help
        exit 0
        ;;
      -v|--version)
        print_version
        exit 0
        ;;
      --update)
        do_update
        exit 0
        ;;
      -m|--message)
        CONTEXT_MSG="$2"
        shift 2
        ;;
      -t|--type)
        FORCED_TYPE="$2"
        shift 2
        ;;
      -s|--scope)
        FORCED_SCOPE="$2"
        shift 2
        ;;
      -i|--interactive)
        INTERACTIVE=true
        shift
        ;;
      -d|--dry-run)
        DRY_RUN=true
        shift
        ;;
      -a|--amend)
        AMEND=true
        shift
        ;;
      --no-stage)
        CLI_AUTO_STAGE=false
        shift
        ;;
      --provider)
        CLI_PROVIDER="$2"
        shift 2
        ;;
      --lang)
        CLI_LANGUAGE="$2"
        shift 2
        ;;
      -*)
        error "Opção desconhecida: $1"
        ;;
      *)
        FILES+=("$1")
        shift
        ;;
    esac
  done
  
  # Carrega configuração
  load_config
  
  # Verificações
  check_dependencies
  
  # Stage de arquivos
  if [ "$AUTO_STAGE" = true ]; then
    if [ ${#FILES[@]} -eq 0 ]; then
      if ! check_staged_changes; then
        if check_unstaged_changes; then
          info "Adicionando todas as alterações ao stage..."
          git add .
        else
          error "Não há alterações para commitar"
        fi
      fi
    else
      info "Adicionando arquivos ao stage: ${FILES[*]}"
      git add "${FILES[@]}"
    fi
  fi
  
  # Verifica se há alterações staged
  if ! check_staged_changes; then
    error "Não há alterações no stage para commitar"
  fi
  
  # Mostra arquivos que serão commitados
  echo ""
  info "Arquivos no stage:"
  get_staged_files | while read -r file; do
    echo -e "  ${CYAN}→${NC} $file"
  done
  echo ""
  
  # Obtém task ID da branch
  TASK_ID=$(get_task_id_from_branch)
  if [ -n "$TASK_ID" ]; then
    info "Task ID detectado: ${BOLD}$TASK_ID${NC}"
  fi
  
  # Gera o prompt
  PROMPT=$(build_prompt "$TASK_ID" "$CONTEXT_MSG" "$FORCED_TYPE" "$FORCED_SCOPE" "$LANGUAGE")
  
  # Gera a mensagem
  info "Gerando mensagem com IA ($AI_PROVIDER)..."
  COMMIT_MSG=$(generate_commit_message "$PROMPT")
  
  if [ -z "$COMMIT_MSG" ]; then
    error "Não foi possível gerar a mensagem de commit"
  fi
  
  echo ""
  echo -e "${BOLD}Mensagem gerada:${NC}"
  echo -e "  ${GREEN}$COMMIT_MSG${NC}"
  echo ""
  
  # Dry run
  if [ "$DRY_RUN" = true ]; then
    info "Modo dry-run: commit não realizado"
    exit 0
  fi
  
  # Modo interativo
  if [ "$INTERACTIVE" = true ]; then
    echo -e "${YELLOW}Deseja realizar o commit? [S/n/e]${NC}"
    echo "  S - Sim, realizar commit"
    echo "  n - Não, cancelar"
    echo "  e - Editar mensagem"
    read -r -n 1 response
    echo ""
    
    case $response in
      [Nn])
        info "Commit cancelado"
        exit 0
        ;;
      [Ee])
        echo -e "${YELLOW}Digite a nova mensagem:${NC}"
        read -r COMMIT_MSG
        ;;
    esac
  fi
  
  # Realiza o commit
  if do_commit "$COMMIT_MSG"; then
    success "Commit realizado: $COMMIT_MSG"
  else
    error "Falha ao realizar commit"
  fi
}

# Executa
main "$@"

