#!/usr/bin/env bash
#
# CommitIA - Gerador de commits inteligentes com IA
# https://github.com/chamizotec/commitia
#
# Gera mensagens de commit seguindo o padrão Conventional Commits
# usando inteligência artificial para analisar suas alterações.
#

set -e

VERSION="1.0.12"
SCRIPT_NAME="commitia"
REPO_URL="https://github.com/chamizotec/commitia"
REPO_RAW_URL="https://raw.githubusercontent.com/chamizotec/commitia/main"

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Configurações padrão (serão aplicadas após carregar o config)
CONFIG_FILE="${HOME}/.commitiarc"
DRY_RUN=false
INTERACTIVE=false
AMEND=false
FORCE_UPDATE=false

# jq disponível? (fallback para grep/sed quando não instalado)
HAS_JQ=false
command -v jq &>/dev/null && HAS_JQ=true

# Output bruto do provedor de IA (para log em caso de erro)
COMMITIA_RAW_OUTPUT=""

# ============================================================================
# Log de erros
# ============================================================================

# Retorna o diretório de logs (.commitia/logs na raiz do repo ou ~/.commitia/logs)
get_log_dir() {
  local git_root
  git_root=$(git rev-parse --show-toplevel 2>/dev/null)
  if [ -n "$git_root" ]; then
    echo "$git_root/.commitia/logs"
  else
    echo "${HOME}/.commitia/logs"
  fi
}

# Cria o diretório de logs e grava arquivo com informações do erro
write_error_log() {
  local raw_output="$1"
  local prompt="$2"
  local diff_content="$3"
  local staged_files="$4"
  local branch="$5"
  
  local log_dir
  log_dir=$(get_log_dir)
  mkdir -p "$log_dir"
  
  local log_file
  log_file="${log_dir}/commitia-error-$(date +%Y%m%d-%H%M%S).log"
  
  {
    echo "=============================================="
    echo "CommitIA - Log de erro na geração do commit"
    echo "=============================================="
    echo "Data/Hora: $(date -Iseconds 2>/dev/null || date)"
    echo "Provedor:  $AI_PROVIDER"
    echo "Branch:    ${branch:- (não em repo git)}"
    echo ""
    echo "--- Arquivos no stage ---"
    echo "$staged_files"
    echo ""
    echo "--- Prompt enviado (início) ---"
    echo "${prompt:0:2000}"
    [ ${#prompt} -gt 2000 ] && echo "... [truncado]"
    echo ""
    echo "--- Diff (staged) ---"
    echo "${diff_content:0:4000}"
    [ ${#diff_content} -gt 4000 ] && echo "... [truncado]"
    echo ""
    echo "--- Resposta bruta do provedor de IA ---"
    echo "$raw_output"
    echo ""
    echo "--- Fim do log ---"
  } > "$log_file"
  
  echo "$log_file"
}

# Remove todos os arquivos de log da pasta de logs (após commit bem-sucedido)
clear_error_logs() {
  local log_dir
  log_dir=$(get_log_dir)
  [ -d "$log_dir" ] && rm -f "${log_dir}"/commitia-error-*.log 2>/dev/null || true
}

# ============================================================================
# Funções de utilidade
# ============================================================================

# Escapa string para uso dentro de JSON (quando jq não está disponível)
json_escape() {
  local s="$1"
  s="${s//\\/\\\\}"
  s="${s//\"/\\\"}"
  s="${s//$'\n'/\\n}"
  s="${s//$'\r'/\\r}"
  s="${s//$'\t'/\\t}"
  printf '%s' "$s"
}

# Extrai campo de texto de respostas JSON (fallback quando sem jq)
# Uso: parse_json_response "$response" "content"  ou "text" ou "response"
# Limitação: mensagens com aspas duplas podem ser cortadas; use jq para conteúdo complexo
parse_json_response() {
  local response="$1"
  local field="$2"
  # Remove prefixo até "field":", depois remove ", ou "} e o restante (fim do valor JSON)
  echo "$response" | sed "s/.*\"${field}\"[[:space:]]*:[[:space:]]*\"//" | \
    sed 's/"[[:space:]]*,[[:space:]]*.*$//; s/"[[:space:]]*}.*$//; s/"[[:space:]]*$//' | \
    sed 's/\\n/\n/g' | sed 's/\\"/"/g'
}

print_banner() {
  echo -e "${PURPLE}"
  echo '   ____                          _ _   ___    _    '
  echo '  / ___|___  _ __ ___  _ __ ___ (_) |_|_ _|  / \   '
  echo ' | |   / _ \| '\''_ ` _ \| '\''_ ` _ \| | __|| |  / _ \  '
  echo ' | |__| (_) | | | | | | | | | | | | |_ | | / ___ \ '
  echo '  \____\___/|_| |_| |_|_| |_| |_|_|\__|___/_/   \_\'
  echo -e "${NC}"
  echo -e "${CYAN}  Commits inteligentes com IA - v${VERSION}${NC}"
  echo ""
}

print_help() {
  print_banner
  echo -e "${BOLD}USO:${NC}"
  echo "  $SCRIPT_NAME [opções] [arquivos...]"
  echo ""
  echo -e "${BOLD}OPÇÕES:${NC}"
  echo "  -m, --message <texto>    Contexto adicional para a mensagem de commit"
  echo "  -t, --type <tipo>        Força um tipo específico de commit"
  echo "  -s, --scope <escopo>     Define o escopo manualmente"
  echo "  -i, --interactive        Modo interativo (confirma antes de commitar)"
  echo "  -d, --dry-run            Apenas mostra a mensagem sem fazer commit"
  echo "  -a, --amend              Altera o último commit"
  echo "  --no-stage               Não adiciona arquivos ao stage automaticamente"
  echo "  --provider <provider>    Define o provedor de IA (amp, openai, gemini, ollama)"
  echo "  --lang <idioma>          Idioma da mensagem (pt, en, es)"
  echo "  --update                 Atualiza para a versão mais recente"
  echo "  --force                  Força atualização (usar com --update)"
  echo "  -v, --version            Mostra a versão"
  echo "  -h, --help               Mostra esta ajuda"
  echo ""
  echo -e "${BOLD}EXEMPLOS:${NC}"
  echo "  $SCRIPT_NAME                        # Commit de todas as alterações"
  echo "  $SCRIPT_NAME src/                   # Commit apenas da pasta src/"
  echo "  $SCRIPT_NAME -m \"corrige bug X\"     # Com contexto adicional"
  echo "  $SCRIPT_NAME -t fix -s auth         # Força tipo 'fix' com escopo 'auth'"
  echo "  $SCRIPT_NAME -i                     # Modo interativo"
  echo "  $SCRIPT_NAME -d                     # Dry-run (apenas mostra a mensagem)"
  echo ""
  echo -e "${BOLD}TIPOS DE COMMIT:${NC}"
  echo "  feat      Nova funcionalidade"
  echo "  fix       Correção de bug"
  echo "  docs      Documentação"
  echo "  style     Formatação, ponto-e-vírgula, etc."
  echo "  refactor  Refatoração de código"
  echo "  test      Adição ou correção de testes"
  echo "  chore     Tarefas de manutenção"
  echo "  perf      Melhorias de performance"
  echo "  ci        Alterações de CI/CD"
  echo "  build     Sistema de build ou dependências"
  echo "  revert    Reversão de commit anterior"
  echo ""
  echo -e "${BOLD}CONFIGURAÇÃO:${NC}"
  echo "  Arquivos de configuração (ordem de prioridade):"
  echo "    1. .commitiarc na raiz do projeto (maior prioridade)"
  echo "    2. ~/.commitiarc (global)"
  echo ""
  echo "  Variáveis disponíveis:"
  echo "    - COMMITIA_PROVIDER: amp, openai, gemini, ollama (padrão: amp)"
  echo "    - COMMITIA_LANGUAGE: pt, en, es (padrão: pt)"
  echo "    - COMMITIA_AUTO_STAGE: true, false (padrão: true)"
  echo ""
}

print_version() {
  echo "CommitIA v${VERSION}"
}

error() {
  echo -e "${RED}✗ Erro: $1${NC}" >&2
  exit 1
}

warn() {
  echo -e "${YELLOW}⚠ Aviso: $1${NC}" >&2
}

success() {
  echo -e "${GREEN}✓ $1${NC}"
}

info() {
  echo -e "${BLUE}ℹ $1${NC}"
}

# ============================================================================
# Validações
# ============================================================================

check_dependencies() {
  # Verifica se está em um repositório git
  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    error "Não está em um repositório Git"
  fi

  # Verifica o provedor de IA
  case "$AI_PROVIDER" in
    amp)
      if ! command -v amp &>/dev/null; then
        error "amp CLI não encontrado. Instale em: https://ampcode.com"
      fi
      ;;
    openai)
      if [ -z "$OPENAI_API_KEY" ]; then
        error "OPENAI_API_KEY não definida"
      fi
      if ! command -v curl &>/dev/null; then
        error "curl não encontrado"
      fi
      if [ "$HAS_JQ" = false ]; then
        warn "jq não encontrado; usando grep/sed (recomendado: brew install jq)"
      fi
      ;;
    ollama)
      if ! command -v ollama &>/dev/null; then
        error "Ollama não encontrado. Instale em: https://ollama.ai"
      fi
      if [ "$HAS_JQ" = false ]; then
        warn "jq não encontrado; usando grep/sed (recomendado: brew install jq)"
      fi
      ;;
    gemini)
      if [ -z "$GEMINI_API_KEY" ]; then
        error "GEMINI_API_KEY não definida. Obtenha em: https://aistudio.google.com/apikey"
      fi
      if ! command -v curl &>/dev/null; then
        error "curl não encontrado"
      fi
      if [ "$HAS_JQ" = false ]; then
        warn "jq não encontrado; usando grep/sed (recomendado: brew install jq)"
      fi
      ;;
    *)
      error "Provedor de IA desconhecido: $AI_PROVIDER"
      ;;
  esac
}

check_staged_changes() {
  if [ -z "$(git diff --staged --name-only)" ]; then
    return 1
  fi
  return 0
}

check_unstaged_changes() {
  if [ -z "$(git diff --name-only)" ] && [ -z "$(git ls-files --others --exclude-standard)" ]; then
    return 1
  fi
  return 0
}

# ============================================================================
# Atualização
# ============================================================================

do_update() {
  print_banner
  info "Verificando atualizações..."
  
  # Verifica se curl está disponível
  if ! command -v curl &>/dev/null; then
    error "curl é necessário para atualização. Instale o curl primeiro."
  fi
  
  # Cria diretório temporário
  local temp_dir
  temp_dir=$(mktemp -d)
  trap "rm -rf $temp_dir" EXIT
  
  # Baixa a versão remota para verificar
  info "Baixando informações da versão mais recente..."
  local remote_script="$temp_dir/commitia"
  
  if ! curl -fsSL "$REPO_RAW_URL/bin/commitia" -o "$remote_script" 2>/dev/null; then
    error "Não foi possível conectar ao repositório. Verifique sua conexão."
  fi
  
  # Extrai versão remota
  local remote_version
  remote_version=$(grep -m1 '^VERSION=' "$remote_script" | cut -d'"' -f2)
  
  if [ -z "$remote_version" ]; then
    error "Não foi possível determinar a versão remota"
  fi
  
  echo ""
  echo -e "  Versão atual:  ${YELLOW}${VERSION}${NC}"
  echo -e "  Versão remota: ${GREEN}$remote_version${NC}"
  echo ""
  
  # Compara versões
  if [ "$VERSION" = "$remote_version" ] && [ "$FORCE_UPDATE" = false ]; then
    success "Você já está na versão mais recente!"
    echo ""
    info "Use --force para reinstalar mesmo assim"
    exit 0
  fi
  
  # Mensagem apropriada
  if [ "$VERSION" = "$remote_version" ]; then
    echo -e "${YELLOW}Reinstalar a mesma versão $remote_version? [S/n]${NC}"
  else
    echo -e "${YELLOW}Deseja atualizar para a versão $remote_version? [S/n]${NC}"
  fi
  read -r -n 1 response
  echo ""
  
  if [[ $response =~ ^[Nn]$ ]]; then
    info "Atualização cancelada"
    exit 0
  fi
  
  # Determina o diretório de instalação
  local install_dir
  local current_script
  current_script=$(command -v commitia 2>/dev/null || echo "$HOME/.local/bin/commitia")
  install_dir=$(dirname "$current_script")
  
  # Faz backup do script atual
  info "Criando backup..."
  cp "$current_script" "$temp_dir/commitia.backup" 2>/dev/null || true
  
  # Instala a nova versão
  info "Instalando versão $remote_version..."
  
  if cp "$remote_script" "$current_script" && chmod +x "$current_script"; then
    success "Atualizado com sucesso para a versão $remote_version!"
    echo ""
    echo -e "${CYAN}Novidades: ${REPO_URL}/releases${NC}"
  else
    # Tenta restaurar backup
    warn "Falha na atualização. Restaurando versão anterior..."
    cp "$temp_dir/commitia.backup" "$current_script" 2>/dev/null || true
    error "Não foi possível atualizar. Verifique as permissões."
  fi
}

# ============================================================================
# Carrega configuração
# ============================================================================

load_config() {
  # Prioridade de configuração:
  # 1. Valores padrão (menor prioridade)
  # 2. ~/.commitiarc (global)
  # 3. .commitiarc na raiz do projeto (local)
  # 4. Linha de comando (maior prioridade)
  
  # Carrega configuração global se existir
  if [ -f "$CONFIG_FILE" ]; then
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
  fi
  
  # Carrega configuração local do projeto (sobrescreve global)
  local project_config
  project_config=$(get_project_config_file)
  
  if [ -n "$project_config" ] && [ -f "$project_config" ]; then
    info "Usando configuração do projeto: $project_config"
    # shellcheck source=/dev/null
    source "$project_config"
  fi
  
  # Aplica valores padrão APÓS carregar os configs
  # Se não foi definido via linha de comando, usa config ou default
  AI_PROVIDER="${CLI_PROVIDER:-${COMMITIA_PROVIDER:-amp}}"
  LANGUAGE="${CLI_LANGUAGE:-${COMMITIA_LANGUAGE:-pt}}"
  AUTO_STAGE="${CLI_AUTO_STAGE:-${COMMITIA_AUTO_STAGE:-true}}"
}

# Encontra o arquivo de configuração do projeto (na raiz do repositório Git)
get_project_config_file() {
  local git_root
  git_root=$(git rev-parse --show-toplevel 2>/dev/null)
  
  if [ -n "$git_root" ] && [ -f "$git_root/.commitiarc" ]; then
    echo "$git_root/.commitiarc"
  fi
}

# ============================================================================
# Extração de informações
# ============================================================================

get_task_id_from_branch() {
  local branch
  branch=$(git branch --show-current 2>/dev/null || echo "")
  
  if [ -n "$branch" ]; then
    # Padrões comuns: ENP-1234, JIRA-123, feature/ABC-999, etc.
    echo "$branch" | grep -oE '[A-Z]+-?[0-9]+' | head -1
  fi
}

get_staged_diff() {
  git diff --staged
}

get_staged_files() {
  git diff --staged --name-only
}

# ============================================================================
# Geração de mensagem com IA
# ============================================================================

build_prompt() {
  local task_id="$1"
  local context="$2"
  local forced_type="$3"
  local forced_scope="$4"
  local lang="$5"
  
  local lang_text
  case "$lang" in
    pt) lang_text="em português" ;;
    en) lang_text="in English" ;;
    es) lang_text="en español" ;;
    *) lang_text="em português" ;;
  esac
  
  local scope_text
  if [ -n "$forced_scope" ]; then
    scope_text="Use '$forced_scope' como escopo."
  elif [ -n "$task_id" ]; then
    scope_text="Use '$task_id' como escopo."
  else
    scope_text="Determine o escopo baseado nos arquivos alterados."
  fi
  
  local type_text
  if [ -n "$forced_type" ]; then
    type_text="Use o tipo '$forced_type'."
  else
    type_text="Tipos permitidos: feat, fix, docs, style, refactor, test, chore, perf, ci, build, revert."
  fi
  
  local prompt="Analise 'git diff --staged' e gere uma mensagem de commit $lang_text no formato 'tipo(escopo): descrição'. $type_text $scope_text A descrição deve ser curta, começar com minúscula e não terminar com ponto."
  
  if [ -n "$context" ]; then
    prompt="$prompt Contexto adicional: \"$context\"."
  fi
  
  prompt="$prompt Retorne APENAS a mensagem no formato correto, sem explicações ou texto adicional."
  
  echo "$prompt"
}

generate_with_amp() {
  local prompt="$1"
  echo "$prompt" | amp -x --dangerously-allow-all 2>&1
}

generate_with_openai() {
  local prompt="$1"
  local diff
  diff=$(get_staged_diff)
  
  local user_content="${prompt}"$'\n\n'"Diff:"$'\n'"${diff}"
  local sys_content="Você é um assistente especializado em gerar mensagens de commit seguindo Conventional Commits."
  
  local json_payload
  if [ "$HAS_JQ" = true ]; then
    json_payload=$(jq -n \
      --arg prompt "$prompt" \
      --arg diff "$diff" \
      '{
        model: "gpt-4o-mini",
        messages: [
          {role: "system", content: "Você é um assistente especializado em gerar mensagens de commit seguindo Conventional Commits."},
          {role: "user", content: ($prompt + "\n\nDiff:\n" + $diff)}
        ],
        temperature: 0.3
      }')
  else
    json_payload=$(printf '{"model":"gpt-4o-mini","messages":[{"role":"system","content":"%s"},{"role":"user","content":"%s"}],"temperature":0.3}' \
      "$(json_escape "$sys_content")" \
      "$(json_escape "$user_content")")
  fi
  
  local response
  response=$(curl -s https://api.openai.com/v1/chat/completions \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $OPENAI_API_KEY" \
    -d "$json_payload")
  
  if [ "$HAS_JQ" = true ]; then
    echo "$response" | jq -r '.choices[0].message.content // empty' 2>/dev/null
  else
    parse_json_response "$response" "content"
  fi
}

generate_with_gemini() {
  local prompt="$1"
  local diff
  diff=$(get_staged_diff)
  
  # API Gemini: https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent
  local model="${COMMITIA_GEMINI_MODEL:-gemini-2.0-flash}"
  local text_content="${prompt}"$'\n\n'"Diff:"$'\n'"${diff}"
  
  local json_payload
  if [ "$HAS_JQ" = true ]; then
    json_payload=$(jq -n \
      --arg prompt "$prompt" \
      --arg diff "$diff" \
      '{
        contents: [{ parts: [{ text: ($prompt + "\n\nDiff:\n" + $diff) }] }],
        generationConfig: { temperature: 0.3, maxOutputTokens: 256 }
      }')
  else
    json_payload=$(printf '{"contents":[{"parts":[{"text":"%s"}]}],"generationConfig":{"temperature":0.3,"maxOutputTokens":256}}' \
      "$(json_escape "$text_content")")
  fi
  
  local response
  response=$(curl -s "https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${GEMINI_API_KEY}" \
    -H "Content-Type: application/json" \
    -d "$json_payload")
  
  if [ "$HAS_JQ" = true ]; then
    echo "$response" | jq -r '.candidates[0].content.parts[0].text // empty' 2>/dev/null
  else
    # Gemini retorna o texto em candidates[0].content.parts[0].text -> campo "text"
    parse_json_response "$response" "text"
  fi
}

generate_with_ollama() {
  local prompt="$1"
  local diff
  diff=$(get_staged_diff)
  
  # Modelo a usar (prefere llama3.2 se disponível, senão codellama)
  local model="llama3.2"
  if ! ollama list 2>/dev/null | grep -q "llama3.2"; then
    model="codellama"
  fi
  
  # Usa o prompt original (que já contém task_id/escopo) + instruções extras para modelos locais
  local full_prompt="Você é um gerador de mensagens de commit Git. Siga EXATAMENTE as instruções abaixo.

INSTRUÇÕES (SIGA COM PRECISÃO):
$prompt

REGRAS OBRIGATÓRIAS:
1. FORMATO EXATO: tipo(escopo): descrição
2. O ESCOPO deve ser EXATAMENTE o que foi especificado nas instruções acima (NÃO use o nome do arquivo)
3. Descrição deve começar com letra MINÚSCULA
4. NÃO usar ponto final
5. Máximo 72 caracteres
6. Retorne APENAS a mensagem, NADA MAIS

DIFF:
$diff

RESPOSTA (apenas a mensagem de commit):"

  # Usa a API REST do Ollama
  local json_payload
  if [ "$HAS_JQ" = true ]; then
    json_payload=$(jq -n \
      --arg model "$model" \
      --arg prompt "$full_prompt" \
      '{ model: $model, prompt: $prompt, stream: false }')
  else
    json_payload=$(printf '{"model":"%s","prompt":"%s","stream":false}' \
      "$model" \
      "$(json_escape "$full_prompt")")
  fi
  
  local response
  response=$(curl -s http://localhost:11434/api/generate \
    -H "Content-Type: application/json" \
    -d "$json_payload")
  
  if [ "$HAS_JQ" = true ]; then
    echo "$response" | jq -r '.response // empty' 2>/dev/null
  else
    parse_json_response "$response" "response"
  fi
}

generate_commit_message() {
  local prompt="$1"
  local output
  
  COMMITIA_RAW_OUTPUT=""
  
  case "$AI_PROVIDER" in
    amp)
      output=$(generate_with_amp "$prompt")
      ;;
    openai)
      output=$(generate_with_openai "$prompt")
      ;;
    gemini)
      output=$(generate_with_gemini "$prompt")
      ;;
    ollama)
      output=$(generate_with_ollama "$prompt")
      ;;
  esac
  
  COMMITIA_RAW_OUTPUT="$output"
  
  # Extrai a mensagem no formato correto
  local msg
  msg=$(echo "$output" | grep -oE '(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)\([^)]*\):.*' | head -1)
  
  # Limpa a mensagem:
  # 1. Remove espaços, ponto final, backticks, asteriscos (markdown)
  # 2. Converte primeira letra da descrição para minúscula
  echo "$msg" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/\.$//;s/`//g;s/\*//g' | \
    perl -pe 's/^([^:]+:\s*)([A-Z])/$1\l$2/'
}

# ============================================================================
# Execução do commit
# ============================================================================

do_commit() {
  local message="$1"
  local amend_flag=""
  
  if [ "$AMEND" = true ]; then
    amend_flag="--amend"
  fi
  
  # shellcheck disable=SC2086
  git commit $amend_flag -m "$message"
}

# ============================================================================
# Main
# ============================================================================

main() {
  # Parse de argumentos
  FILES=()
  CONTEXT_MSG=""
  FORCED_TYPE=""
  FORCED_SCOPE=""
  
  # Variáveis CLI (prioridade sobre config)
  CLI_PROVIDER=""
  CLI_LANGUAGE=""
  CLI_AUTO_STAGE=""
  DO_UPDATE=false
  
  while [[ $# -gt 0 ]]; do
    case $1 in
      -h|--help)
        print_help
        exit 0
        ;;
      -v|--version)
        print_version
        exit 0
        ;;
      --update)
        DO_UPDATE=true
        shift
        ;;
      --force)
        FORCE_UPDATE=true
        shift
        ;;
      -m|--message)
        CONTEXT_MSG="$2"
        shift 2
        ;;
      -t|--type)
        FORCED_TYPE="$2"
        shift 2
        ;;
      -s|--scope)
        FORCED_SCOPE="$2"
        shift 2
        ;;
      -i|--interactive)
        INTERACTIVE=true
        shift
        ;;
      -d|--dry-run)
        DRY_RUN=true
        shift
        ;;
      -a|--amend)
        AMEND=true
        shift
        ;;
      --no-stage)
        CLI_AUTO_STAGE=false
        shift
        ;;
      --provider)
        CLI_PROVIDER="$2"
        shift 2
        ;;
      --lang)
        CLI_LANGUAGE="$2"
        shift 2
        ;;
      -*)
        error "Opção desconhecida: $1"
        ;;
      *)
        FILES+=("$1")
        shift
        ;;
    esac
  done
  
  # Executa update se solicitado
  if [ "$DO_UPDATE" = true ]; then
    do_update
    exit 0
  fi
  
  # Carrega configuração
  load_config
  
  # Verificações
  check_dependencies
  
  # Stage de arquivos
  if [ "$AUTO_STAGE" = true ]; then
    if [ ${#FILES[@]} -eq 0 ]; then
      if ! check_staged_changes; then
        if check_unstaged_changes; then
          info "Adicionando todas as alterações ao stage..."
          git add .
        else
          error "Não há alterações para commitar"
        fi
      fi
    else
      info "Adicionando arquivos ao stage: ${FILES[*]}"
      git add "${FILES[@]}"
    fi
  fi
  
  # Verifica se há alterações staged
  if ! check_staged_changes; then
    error "Não há alterações no stage para commitar"
  fi
  
  # Mostra arquivos que serão commitados
  echo ""
  info "Arquivos no stage:"
  get_staged_files | while read -r file; do
    echo -e "  ${CYAN}→${NC} $file"
  done
  echo ""
  
  # Obtém task ID da branch
  TASK_ID=$(get_task_id_from_branch)
  if [ -n "$TASK_ID" ]; then
    info "Task ID detectado: ${BOLD}$TASK_ID${NC}"
  fi
  
  # Gera o prompt
  PROMPT=$(build_prompt "$TASK_ID" "$CONTEXT_MSG" "$FORCED_TYPE" "$FORCED_SCOPE" "$LANGUAGE")
  
  # Gera a mensagem
  info "Gerando mensagem com IA ($AI_PROVIDER)..."
  COMMIT_MSG=$(generate_commit_message "$PROMPT")
  
  if [ -z "$COMMIT_MSG" ]; then
    LOG_PATH=$(write_error_log \
      "$COMMITIA_RAW_OUTPUT" \
      "$PROMPT" \
      "$(get_staged_diff)" \
      "$(get_staged_files)" \
      "$(git branch --show-current 2>/dev/null || echo '')")
    echo ""
    echo -e "${RED}✗ Erro: Não foi possível gerar a mensagem de commit${NC}" >&2
    echo -e "  Log gravado em: ${BOLD}$LOG_PATH${NC}" >&2
    exit 1
  fi
  
  echo ""
  echo -e "${BOLD}Mensagem gerada:${NC}"
  echo -e "  ${GREEN}$COMMIT_MSG${NC}"
  echo ""
  
  # Dry run
  if [ "$DRY_RUN" = true ]; then
    info "Modo dry-run: commit não realizado"
    exit 0
  fi
  
  # Modo interativo
  if [ "$INTERACTIVE" = true ]; then
    echo -e "${YELLOW}Deseja realizar o commit? [S/n/e]${NC}"
    echo "  S - Sim, realizar commit"
    echo "  n - Não, cancelar"
    echo "  e - Editar mensagem"
    read -r -n 1 response
    echo ""
    
    case $response in
      [Nn])
        info "Commit cancelado"
        exit 0
        ;;
      [Ee])
        echo -e "${YELLOW}Digite a nova mensagem:${NC}"
        read -r COMMIT_MSG
        ;;
    esac
  fi
  
  # Realiza o commit
  if do_commit "$COMMIT_MSG"; then
    clear_error_logs
    success "Commit realizado: $COMMIT_MSG"
  else
    error "Falha ao realizar commit"
  fi
}

# Executa
main "$@"

